{"version":3,"file":"PasskeySetup.js","mappings":"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","sources":["webpack:///../../../../../node_modules/@simplewebauthn/browser/dist/bundle/index.js","webpack:///./PasskeySetup.js"],"sourcesContent":["/* [@simplewebauthn/browser@7.1.0] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return ((window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== undefined && typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor(message, name = 'WebAuthnError') {\n        super(message);\n        this.name = name;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    var _a, _b;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Registration ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            return new WebAuthnError('Discoverable credentials were required but no available authenticator supported it', 'ConstraintError');\n        }\n        else if (((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === 'required') {\n            return new WebAuthnError('User verification was required but no available authenticator supported it', 'ConstraintError');\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError('The authenticator was previously registered', 'InvalidStateError');\n    }\n    else if (error.name === 'NotAllowedError') ;\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter(param => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError('No entry in pubKeyCredParams was of type \"public-key\"', 'NotSupportedError');\n        }\n        return new WebAuthnError('No available authenticator supported any of the specified pubKeyCredParams algorithms', 'NotSupportedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rp.id}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError('User ID was not between 1 and 64 characters', 'TypeError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new credential', 'UnknownError');\n    }\n    return error;\n}\n\nclass WebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            this.controller.abort('Cancelling existing WebAuthn API call for new one');\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n}\nconst webauthnAbortService = new WebAuthnAbortService();\n\nconst attachments = ['cross-platform', 'platform'];\nfunction toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n\nasync function startRegistration(creationOptionsJSON) {\n    var _a;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: (_a = creationOptionsJSON.excludeCredentials) === null || _a === void 0 ? void 0 : _a.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nasync function browserSupportsWebAuthnAutofill() {\n    const globalPublicKeyCredential = window.PublicKeyCredential;\n    return (globalPublicKeyCredential.isConditionalMediationAvailable !== undefined &&\n        globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Authentication ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'NotAllowedError') ;\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rpId}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new assertion signature', 'UnknownError');\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    var _a, _b;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {\n        allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete*='webauthn']\");\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with `\"webauthn\"` in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nasync function platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return false;\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n","import {\n  browserSupportsWebAuthn,\n  platformAuthenticatorIsAvailable,\n} from '@simplewebauthn/browser';\nimport {startRegistration} from '@simplewebauthn/browser';\n\n/** global: Craft */\n/** global: Garnish */\nCraft.PasskeySetup = Garnish.Base.extend({\n  $passkeysTable: null,\n  $addPasskeyBtn: null,\n  $errors: null,\n\n  async init() {\n    this.$passkeysTable = $('#passkeys');\n    this.$addPasskeyBtn = $('#add-passkey-btn');\n    this.$errors = $('#passkey-errors');\n\n    if (\n      !browserSupportsWebAuthn() ||\n      !(await platformAuthenticatorIsAvailable())\n    ) {\n      const $container = $('<div class=\"readable\"/>');\n      $('<blockquote/>', {\n        class: 'note warning',\n        text: Craft.t('app', 'This browser doesn’t support passkeys.'),\n      }).appendTo($container);\n      this.$addPasskeyBtn.replaceWith($container);\n      return;\n    }\n\n    this.initTable();\n    this.addListener(this.$addPasskeyBtn, 'activate', 'createPasskey');\n  },\n\n  initTable() {\n    this.addListener(this.$passkeysTable.find('.delete'), 'activate', (ev) => {\n      ev.preventDefault();\n      const $button = $(ev.currentTarget);\n      this.deletePasskey($button.data('uid'), $button.data('name'));\n    });\n  },\n\n  updateTable(html) {\n    this.$passkeysTable.html(html);\n    this.initTable();\n  },\n\n  async createPasskey() {\n    if (this.$addPasskeyBtn.hasClass('loading')) {\n      return;\n    }\n\n    this.$addPasskeyBtn.addClass('loading');\n\n    try {\n      await (() =>\n        new Promise((resolve, reject) => {\n          try {\n            Craft.elevatedSessionManager.requireElevatedSession(\n              async () => {\n                await this.startRegistration();\n                resolve();\n              },\n              () => {\n                resolve();\n              },\n              Math.min(Craft.elevatedSessionDuration, 300)\n            );\n          } catch (e) {\n            reject(e);\n          }\n        }))();\n    } finally {\n      this.$addPasskeyBtn.removeClass('loading');\n    }\n  },\n\n  async startRegistration() {\n    // GET registration options from the endpoint that calls\n    let data;\n    try {\n      const response = await Craft.sendActionRequest(\n        'POST',\n        'auth/passkey-creation-options'\n      );\n      data = response.data;\n    } catch (e) {\n      Craft.cp.displayError(e?.response?.data?.message);\n      return;\n    }\n\n    let defaultName = this.browserName() + ' on ' + this.platformName();\n    const credentialName = prompt(\n      Craft.t('app', 'Enter a name for the passkey.'),\n      defaultName\n    );\n\n    if (credentialName === null) {\n      return;\n    }\n\n    let regResponse;\n\n    try {\n      regResponse = await startRegistration(data.options);\n    } catch (e) {\n      Craft.cp.displayError(e?.message);\n      return;\n    }\n\n    this.verifyRegistration(regResponse, credentialName);\n  },\n\n  async verifyRegistration(startRegistrationResponse, credentialName) {\n    let data;\n\n    try {\n      const response = await Craft.sendActionRequest(\n        'POST',\n        'auth/verify-passkey-creation',\n        {\n          data: {\n            credentials: JSON.stringify(startRegistrationResponse),\n            credentialName: credentialName,\n          },\n        }\n      );\n      data = response.data;\n    } catch (e) {\n      Craft.cp.displayError(e?.response?.data?.message);\n      return;\n    }\n\n    Craft.cp.displaySuccess(data.message);\n    this.updateTable(data.tableHtml);\n  },\n\n  async deletePasskey(uid, name) {\n    if (\n      !confirm(\n        Craft.t(\n          'app',\n          'Are you sure you want to delete the “{name}” passkey?',\n          {name}\n        )\n      )\n    ) {\n      return;\n    }\n\n    let data;\n\n    try {\n      const response = await Craft.sendActionRequest(\n        'POST',\n        'auth/delete-passkey',\n        {\n          data: {uid},\n        }\n      );\n      data = response.data;\n    } catch (e) {\n      Craft.cp.displayError(e?.response?.data?.message);\n      return;\n    }\n\n    Craft.cp.displaySuccess(data.message);\n    this.updateTable(data.tableHtml);\n  },\n\n  platformName() {\n    const platform = navigator.platform;\n\n    if (platform.indexOf('Mac') !== -1) {\n      return 'Mac';\n    }\n    if (platform.indexOf('iPhone') !== -1 || platform.indexOf('Pike')) {\n      return 'iPhone';\n    }\n    if (platform.indexOf('iPad') !== -1) {\n      return 'iPad';\n    }\n    if (platform.indexOf('iPod') !== -1) {\n      return 'iPod';\n    }\n    if (platform.indexOf('FreeBSD') !== -1) {\n      return 'FreeBSD';\n    }\n    if (platform.indexOf('Linux') !== -1) {\n      return 'Linux';\n    }\n    if (platform.indexOf('Win') !== -1) {\n      return 'Windows';\n    }\n    if (platform.indexOf('Nintendo') !== -1) {\n      return 'Nintendo';\n    }\n    if (platform.indexOf('SunOS') !== -1) {\n      return 'Solaris';\n    }\n    // in other cases - just use the full name returned by navigator.platform\n    return platform;\n  },\n\n  browserName() {\n    const userAgent = navigator.userAgent;\n\n    if (userAgent.match(/chrome|chromium|crios/i)) {\n      return 'Chrome';\n    }\n    if (userAgent.match(/firefox|fxios/i)) {\n      return 'Firefox';\n    }\n    if (userAgent.match(/safari/i)) {\n      return 'Safari';\n    }\n    if (userAgent.match(/opr\\//i)) {\n      return 'Opera';\n    }\n    if (userAgent.match(/edg/i)) {\n      return 'Edge';\n    }\n    if (userAgent.match(/trident/i)) {\n      return 'IE';\n    }\n    return 'Browser';\n  },\n});\n"],"names":["bufferToBase64URLString","buffer","bytes","Uint8Array","str","charCode","String","fromCharCode","btoa","replace","base64URLStringToBuffer","base64URLString","base64","padLength","length","padded","padEnd","binary","atob","ArrayBuffer","i","charCodeAt","browserSupportsWebAuthn","undefined","window","PublicKeyCredential","toPublicKeyCredentialDescriptor","descriptor","id","transports","WebAuthnError","Error","constructor","message","name","super","this","webauthnAbortService","createNewAbortSignal","controller","abort","newController","AbortController","signal","attachments","toAuthenticatorAttachment","attachment","indexOf","async","creationOptionsJSON","_a","value","options","publicKey","challenge","user","TextEncoder","encode","excludeCredentials","map","credential","navigator","credentials","create","err","error","_b","authenticatorSelection","requireResidentKey","userVerification","pubKeyCredParams","filter","param","type","effectiveDomain","location","hostname","test","rp","byteLength","identifyRegistrationError","rawId","response","getTransports","attestationObject","clientDataJSON","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","platformAuthenticatorIsAvailable","isUserVerifyingPlatformAuthenticatorAvailable","Craft","PasskeySetup","Garnish","Base","extend","$passkeysTable","$addPasskeyBtn","$errors","init","$","$container","class","text","t","appendTo","replaceWith","initTable","addListener","find","ev","preventDefault","$button","currentTarget","deletePasskey","data","updateTable","html","createPasskey","hasClass","addClass","Promise","resolve","reject","elevatedSessionManager","requireElevatedSession","startRegistration","Math","min","elevatedSessionDuration","e","removeClass","sendActionRequest","cp","displayError","defaultName","browserName","platformName","credentialName","prompt","regResponse","verifyRegistration","startRegistrationResponse","JSON","stringify","displaySuccess","tableHtml","uid","confirm","platform","userAgent","match"],"sourceRoot":""}